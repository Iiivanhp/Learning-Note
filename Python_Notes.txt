Python笔记 
source：http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000

零、	python基础
1.数据类型和变量

2.字符串和编码

3.list和tuple

4.条件判断
	age = 20
	if age >= 18:   #注意冒号
		print('your age is', age)
		print('adult')
	#根据缩进来判断程序块
	elif age >= 6:
		print('teenager')
	else:
		print('your age is', age)
		print('kid')
5.循环

6.dict和set

一、	Python-函数
1.	函数调用
a)	https://docs.python.org/3/library/functions.html  python内置函数，可通过help（）查看函数作用
b)	数据类型转换函数 int（） float（）str（） bool（）
2.	定义函数
a)	在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。如果没有返回值，可以直接return
eg.
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
b)	如果已经定义好的函数保存在文件中，可以通过import调用
c)	空函数：pass语句，用作占位符
d)	函数错误：isinstance（变量，（类型））检查参数；TypeError（’str’）错误提示函数
e)	返回值：函数可返回多个值，即返回tuple
3.	函数参数
a)	位置参数：按照位置顺序依次赋值
b)	默认参数：设定默认值，注意：一是必选参数在前，默认参数在后，否则Python的解释器会报错；参数的默认值必须是不变对象，像是默认L=[ ] 的默认参数，默认调用时会报错。
c)	可变参数：传入参数的个数是可变的，与位置参数不同。考虑传入的参数是一个tuple或者list，则tuple中的变量个数不固定。但在传参是比较麻烦，变成calc([1, 2, 3])。此时可以使用可变参数，如def calc(*numbers) 此时调用时可写成calc(1, 2, 3)。如果此时已经有了一个tuple，也可以通过calc（*nums）的形式调用nums这一个tuple。
d)	关键字参数：关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。
可先组装一个dict，然后调用dict
>>> extra = {'city': 'Beijing', 'job': 'Engineer'}
>>> person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
也可通过**extra的方式传参，
>>> person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
e)	命名关键字参数：限制关键字名字。例如只接受city和job
def person(name, age, *, city, job):
print(name, age, city, job)
		此时调用时需要加入关键字名称，如
		>>> person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
*是特殊分隔符，区分位置参数和命名关键字参数，若参数中含可变参数，则*可省略。如果命名关键字参数有默认值，可以不传入。
f)	参数组合
参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。
4.	递归函数
a)	在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
可以通过尾递归的方法优化，即在调用函数时只调用函数本身，不含表达式。
二、	高级特性
1.	切片
取一个list或tuple的部分元素。L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片。如L[-3:]代表后三个数字。其中冒号左边指向的元素被选取，冒号右边的不被选取。
[:]代表复制一个list。[：：2]代表每两个取一个。
切边操作可以用于list，tuple，字符串。
2.	迭代
a)	如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代。通常用for in 循环来迭代。对于dict，迭代关键字是for k in d: ；迭代值用for k in d.values()；同时迭代关键字和值可以用for k,v in d.items()；字符串也可以迭代；
b)	判断一个对象是否可迭代，可通过Iterable类型判断：
>>> from collections import Iterable
>>> isinstance('abc', Iterable) # str是否可迭代
True
>>> isinstance([1,2,3], Iterable) # list是否可迭代
True
>>> isinstance(123, Iterable) # 整数是否可迭代
False
c)	下标循环：enumerate函数。
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
3.	列表生成式
a)	生成顺序数列：list(range(10));  list(range(5,10));
生成平方数列：>>> [x * x for x in range(1, 11)]
生成偶数平方数列：>>> [x * x for x in range(1, 11) if x % 2 == 0]（使用条件语句）
生成全排列：>>> [m + n for m in 'ABC' for n in 'XYZ']（双重循环）
检查+小写转化：[s.lower() for s in L1 if isinstance(s,str)]
4.	生成器
a)	在Python中，一边循环一边计算的机制，称为生成器：generator。不必创建完整的list，从而节省大量的空间。只要把一个列表生成式的[]改成()，就创建了一个generator：
>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>
			g中元素可通过next（g）调用，也可通过for in 循环调用。
另外一种生成器的写法是在函数中引入yield。变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
def odd():
    print('step 1')
    yield 1
    print('step 2')
    yield(3)
    print('step 3')
yield(5)
5.	迭代器
a)	For循环可作用于1.集合数据类型，如list、tuple、dict、set、str等2.generator，包括生成器和带yield的函数。可直接作用于for循环的对象统称为可迭代对象Iterable。可用isinstance判断。
b)	可被next（）函数调用并不断返回下一个值的对象成为迭代器Iterator。同样可通过isinstance判断。生成器都是迭代器，但list等数据类型不是，需通过iter（）函数转化。
这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。
c)	For循环本质上是一个迭代器不断调用next（）。
for x in [1, 2, 3, 4, 5]:
pass
			等价于一下过程
		# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
    	    # 获得下一个值:
    	    x = next(it)
    except StopIteration:
       			# 遇到StopIteration就退出循环
      			break	
三、	函数式编程
1.	函数式编程
a)	函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。
b)	函数式编程就是一种抽象程度很高的编程范式。纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
2.	高阶函数
a)	变量可以指向函数。函数名其实就是指向函数的变量。
b)	传入函数：既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。编写高阶函数，就是让函数的参数能够接收别的函数。
def add(x, y, f):
	return f(x) + f(y)
add(-5, 6, abs)
c)	map函数：map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。可以通过list函数计算所有结果。
d)	reduce函数：reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数是二元算子，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)。
from functools import reduce

def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
return reduce(lambda x, y: x * 10 + y, map(char2num, s))
字符串转化为整数，其中lambda相当于函数简化写法
e)	filter函数：filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
f)	sorted函数：Python内置的sorted()函数就可以对list进行排序。sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序。sorted([36, 5, -12, 9, -21], key=abs)。传入key=str.lower可以忽略大小写区别。使用参数reserve=True 可.以从大到小排序。
3.	函数作为返回值
 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
return sum
此时调用该函数返回的是一个函数而不是一个值，参数虽被调用，但不会计算出结果。内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
def count():	#返回一个函数的list
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs
f1, f2, f3 = count()  #三个函数不同，但产生的结果相同
由于返回函数f1、f2使用变量i，在循环过程中i变化，返回函数取i的最终值作为参数。所以f1() f2() f3()的值都为9。
若返回函数需要使用变量，方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入g()
return fs
4.	匿名函数
lambda表达式，不需要显式地定义函数。匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。匿名函数本身也是一个对象，可以被赋值给另一个变量。f = lambda x: x * x
5.	装饰器
在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。即在原函数基础上增加新的过程。
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
return wrapper
	此处log传入一个函数参数func，返回的是一个print过程+func的组合函数log。
@语法：把@log放到now()函数的定义处，相当于执行了语句：now = log(now)
Functools.wraps:复制原始函数属性到新函数中
eg.可传参可不传参的log动态函数（作业2）
import functools
def log(text):
	def decorator(func=text):
		@functools.wraps(func)
		def wrapper(*args,**kw):
			if callable(text):
				print('call %s():' % (func.__name__))
				return func(*args,**kw)
			else:
				print('call %s %s():' % (text, func.__name__))
				return func(*args,**kw)
		return wrapper
	if callable(text):
		return decorator()
	else:
		return decorator
6.	偏函数
functools.partial, 把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。偏函数的参数可以有三个，函数对象，*args和**kw。在新函数需要大规模调用时可以简化程序。
eg: int2=functools.partial(int,base=2); max2=functools.partial(max,10)#=max(10,*args)
四、	模块
1.	模块
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。
为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，abc.py模块的名字就变成了mycompany.abc，类似的，xyz.py的模块名变成了mycompany.xyz。
每个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。
2.	使用模块
a)	标准模板：
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
            print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
test()
第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码；
第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；
第6行使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；
当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败。即判断当前环境是否为命令行cmd。
b)	作用域与_前缀
正常的函数和变量名是公开的（public），可以被直接引用，比如：abc；类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，如__name__;类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，通常出现于模块的内部逻辑中，不对外公开，一般封装在公开函数中，但外部一般不能直接调用。
3.	第三方模块安装（略）
五、	面向对象编程
1.	简介
面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是Student这种数据类型应该被视为一个对象，这个对象拥有name和score这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个print_score消息，让对象自己把自己的数据打印出来。给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。
和C++中类似。对象中含有数据和对数据操作的函数，从而通过调用对象的函数来实现目的。
2.	类和实例
面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
每个类的实例可以自由的添加新的属性，通常使用新变量。
类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去。
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
数据封装：通过直接在Student类的内部定义访问数据的函数，“数据”被封装了，也就是不须通过外部调用。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法，通常使用时不需要知道具体细节。
3.	访问限制
在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。
要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，确保变量稳定。我们可以设定类的方法来修改内部参数，这样可以通过变量检查防止无效输入。
要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量。有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。
4.	继承和多态
当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法。当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思。
开闭原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。也可以说，调用方调用时不需要细节，只有run（）函数可用就可以使用父类型的run_twice函数。
		判断一个变量是否是某个类型可以用isinstance()判断。
静态语言 vs 动态语言：静态语言在传入实例时是有类型要求的，而动态语言不需要，只要函数可用使用就行。
5.	获取对象信息：
首先，我们来判断对象类型，使用type()函数。判断一个对象是否是函数，可以使用types模块中定义的常量。
如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法。dir(‘ABC’)
类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法。我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法，这样就可以用len调用我们生成的类。
三个重要的属性：hasattr()：对象是否具有某个属性；setattr():设置一个新属性；getattr（）：获取对象的属性或方法。getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404。
6.	实例属性和类属性:实例属性优先级高，会覆盖类属性。
六、	面向对象高级编程
1.	给实例绑定方法
methodtype函数；给所以class绑定方法：类.方法=函数。MethodType函数用于类的情况比较特殊，会改变同一类的所有实例。
2.	使用__slots__:
若要限制实例的属性，可以使用__slot__变量，通过tuple定义允许绑定的属性名称。这个定义不会影响子类。即使说，子类可以添加新属性，但子类的实例也收到slot限制。
3.	@property语法
首先，通过方法来赋值，可以再赋值时检查参数错误或者类型错误，减少逻辑错误。但为了在赋值时方便起见，可以通过@property语法将方法转为属性调用，从而使用起来比较方便。
@property 将一个getter方法变成属性；
@score.setter 将score（可换其他属性名）的赋值方法变成属性赋值。
4.	多重继承
通过继承多个父类，获得多重功能。MixIn设计，就是通过设计主线继承外额外的功能，将其做为一个类，继承给子类。这样可以通过不同MixIn的组合，创造出多种子类。
5.	定制类
特殊用途的__xx__方法和变量可以写进自己定义的类，如slots和len，本章给出其余几个例子。
a)	__str__：返回给用户看的字符串（print），另__repr__为返回给开发者字符串，使用与交互界面。可在类的定义中使__repr__=__str__
b)	__iter__：该方法返回一个迭代对象，可以使用for循环调用该迭代对象的__next__方法来拿到循环的下一个值，并在StopIteration时退出循环。
Eg：斐波那契数列对象类
c)	__getitem__:该方法用于通过下标取出元素，使对象可以像list一样使用。
	但list可以使用切片，如果要使对象也可以使用切片，需做进一步处理。对于传入参数做判断是int还是切片对象slice。
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a, b = b, a + b
            return L
类似的还有setitem和delitem方法，分别对应list赋值和元素删除。
d)	__getattr__：
当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，我们可以自己编写getattr方法，这样我们就有机会返回score的值，并对我们不想回应的输入调用attributeerror错误。
价值：完全动态化处理类的属性和方法，可以再完全动态化的情况下做调用。如可以使用动态化的链式调用对不同的api写sdk。
e)	__call__:
__call__方法是类方法，可将实例对象转化为一个方法（函数）来调用。
6.	枚举类：
Enum类：from enum import Enum；month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
month是Enum类的实例名，month.__members__是一个ordereddict，对应枚举集合的名字与对象的一对多映射。枚举类会按顺序赋予枚举对象自然数值。
衍生：自定义枚举类可以自行定义枚举对象的值。使用@unique语法可以确保值不重复。
7.	使用元类：
a)	Type（）函数：除了查看变量类型，也可创建新的类、
七、	Learn Python the Hard way
1.	Print 相关
a)	在2.x版本中，print 是一个过程不是函数，参数不加括号
b)	2.x 中Print x， 代表不换行输出，会添加一个空格；在3.x中print作为一个函数，不换行需要设置参数end如 print（x,end=’’）。此时不会添加空格
c)	print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)是原型。其中sep代表各个元素间的分隔，默认为空格，file表示输出调用的方式，默认为stdout；flush表示读完内存（？）
2.	字符串处理
a)	格式化：%r 转化的是开发者输入的数据，%s %d 等转化的是用户看到的数据，这是关键区别。%r等统称占位符。例子：%r对换行符不起作用，因为对开发者来说是‘\n’，但%s可以使用。
b)	当%没有代入变量是，%语法将当成普通的字符串。另外，普通的%需要转义成%%。
c)	\n:换行符；’’’…………’’’可以将段落块当成一个整体，在shell里可以进行多行输入；\a:响铃 ；\b：退格
d)	 
八、	
